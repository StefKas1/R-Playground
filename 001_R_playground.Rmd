---
title: "R Notebook"
output: html_notebook
---

```{r}
getwd() # Curren working dir.
```

```{r}
# Changes dir.
# setwd("path of dir")
```

```{r}
sum <- 3 + 5
sum
```

```{r}
vector <- c(1, 2, 3)
vector
```

```{r}
vector <- c(1, 2, 3) + 2^3
vector
```

```{r}
vector[1] # Gets element at position 1 (R does not start with index 0 but 1).
```

```{r}
vector[c(1, 3)] # Gets element at position 1 and 3.
```

```{r}
vector[1] <- 100 # Sets new value for item with position 1.
vector
```

```{r}
rep(c(1, 2, 3), each=3)
rep(c(1, 2, 3), times=3)
rep(c(1, 2, 3), times=c(5, 2, 1))
```

```{r}
1:20
```

```{r}
seq(1, 20, by=0.5)
```

```{r}
seq(5, 10, length=30)
```

```{r}
c("String 1", "String 2", "String 3")
```

```{r}
result <- c(1, 2, 3, 4, 5) < 3
result
```

```{r}
length(result)
```

```{r}
li <- list(1, 2, 3, "a", "b", "c")
li
```

```{r}
li[2:4]
```

```{r}
li[1] <- 100
li
```

```{r}
"a" %in% li # Checks if "a" is in li.
```

```{r}
li <- append(li, "new value")
li
```

```{r}
li <- append(li, "after 1st element", after=1)
li
```

```{r}
li <- li[-2] # Removes 2nd element.
li
```

```{r}
for (element in li) {
  print(element)
}
```

```{r}
joined_list = c(list(1, 2, 3), list(4, 5, 6))
joined_list
```

```{r}
array_1 = array(c(1:24), dim=c(4, 3, 2)) # dim=(rows, columns, matrices).
array_1
```

```{r}
array_2 = array(c(1:24), dim=c(2, 3, 4)) # dim=(rows, columns, matrices).
array_2
```

```{r}
array_2[1, 2, 3] # Row 1, column 2, in matrix 3.
```

```{r}
array_2[, 2, ] # All rows, column 2, all matrices.
```

```{r}
dim(array_2) # Gets dimension.
```

```{r}
v1 <- c("A", "B", "C")
v2 <- c(1, 2, 3)

#DataFrame.
df = data.frame(v1, v2)
df
```

```{r}
summary(df)
```

```{r}
df[1] # Gets first column.
```

```{r}
df[["v1"]] # Gets column with name v1.
```

```{r}
df$v1 # Gets column with name v1.
```

```{r}
df <- rbind(df, c("D",4)) # Adds new row to df.
df
```

```{r}
df <- cbind(df, "v3"=c(10, 20, 30, 40)) # Adds new column to df.
df
```

```{r}
df[-c(1),] # Removes first row of df.

```

```{r}
df[,-c(1)] # Removes first column of df.
```

```{r}
5 %% 3 # Modulus
5 %/% 3 # Integer division.
```

```{r}
a <- 5
b <- 3

if (b > a) {
  print("b is greater than a")
} else if (b < a) {
  print ("a is greater than b")
} else {
  print("a and b are equal")
}
```

```{r}
function_name <- function(x) {
  return (x * x)
}

function_name(3)
```

```{r}
f <- function(x, y=3) { # y is default argument.
  return (x + y)
}

f(4)
```

```{r}
f_args <- function(...) { # ... args.
  li <- list(...)
  return (sum(unlist(li))) # (sum(...)) would be better.
}

f_args(1, 2, 3, 4)
```

```{r}
# lapply: Takes list, vector or DataFrame and function - and applies function to
# each element. Returns list.
li <- list(16, 25, 36)
lapply(li, sqrt)
```

```{r}
# sapply: Takes list, vector or DataFrame and function - and applies function to
# each element. Returns vector.
sapply(li, sqrt)
```

```{r}
# Same as sapply, but specify expected return type; here it is a vector.
vapply(li, sqrt, c(0))
```

```{r}
prices <- c(10, 20, 30, 40, 50, 60)
product_types <- c(1, 1, 1, 2, 2, 2)

# tapply groups prices by product_types and then applies function mean.
tapply(prices, product_types, mean)
```

```{r}
sample(1:6, 4, replace=TRUE) # Samples 4 values from 1, 2 to 6 - with replacement.
```

```{r}
sample(c(0, 1, 2, 3), 2)
```

```{r}
sample(c(0,1), 100, replace=TRUE, prob=c(0.3, 0.7)) # Prob for 0 is 0.3, and for 1 is 0.7.
```

```{r}
rbinom(1, size=100, prob=0.7) # Binomial distribution, prob for 1 is 0.7.
```

```{r}
rnorm(10) # Generates 10 random numbers from a standard normal distribution (mean=0, std=1).
```

```{r}
rn <- rnorm(10, 20) # Generates 10 random numbers from normal distribution with standard deviation 20.
rn
```

```{r}
replicate(5, rn) # Does rn 5 times.
```

```{r}
plot(1, 2)
```

```{r}
plot(c(1, 2, 3), c(3, 5, 10))
```

```{r}
# type="l": line.
plot(c(1, 2, 3), c(3, 5, 10), type="l", main="Title", xlab="x-axis", ylab="y-axis")
```

```{r}
# Plots multiple lines.
x <- c(1, 2, 3)
plot(x, c(3, 5, 10), type="l", col="blue")
lines(x, c(7, 2, 9), col="red")
lines(x, c(8, 4, 5), col="green")

# Adds legend. lty: line type as an integer
legend(1, 10, legend=c("Line 1", "Line 2", "Line 3"), col=c("blue", "red", "green"),  lty=1)
```

```{r}
# Scatter plot.
x1 <- sample(1:20, 20, replace=TRUE)
y1 <- sample(1:20, 20, replace=TRUE)

x2 <- sample(1:20, 20, replace=TRUE)
y2 <- sample(1:20, 20, replace=TRUE)

plot(x1, y1, col="red", pch=19, xlab="x-axis", ylab="y-axis")
points(x2, y2, col="blue", pch=19)
```

```{r}
mtcars # Built-in data set.
```

```{r}
?mtcars # Shows R documentation for mtcars.
```

```{r}
names(mtcars) # Gets column names.
```

```{r}
rownames(mtcars) # Gets row names.
```

```{r}
mtcars[, "mpg"] # Gets all values of column mpg.
#mtcars$mpg
# ^^ wil give same result.
```

```{r}
mtcars["Mazda RX4", ] # Gets all values of row "Mazda RX4".
```

```{r}
summary(mtcars)
```

```{r}
mpg <- mtcars[, "mpg"]
print(max(mpg)) # Gets max value of mpg column, but which row?

max_mpg_index <- which.max(mpg) # Gets index of mpg column of row with max value.
print(max_mpg_index)

mtcars[max_mpg_index, ] # Shows row with max value.
```

```{r}
rownames(mtcars) # Remember, these are the row names. 
```

```{r}
rownames(mtcars)[max_mpg_index] # So, this will give the car with the highest/max mpg.
```

```{r}
mean(mtcars$hp)
median(mtcars$hp)
quantile(mtcars$hp, c(0.25))
quantile(mtcars$hp, c(0.75))
```

```{r}
# print("a" + 2) # Will not work.
print(paste("a", 2)) # Works.
```

```{r}
# Install package if not installed. require() does same as library(), but has a return value.
if(!require("ggplot2")){
  install.packages("ggplot2")
  library(ggplot2) # Imports library ggplot2; (require() does also import library).
}
```

```{r}
print(df)
ggplot(df, aes(x=v2, y=v3, colour=v1)) + geom_point() #, colour=df$v1)
```

```{r}
df <- read.csv("data/diamonds_regression_raw.csv", header=TRUE, na.strings="NA")
df
```

```{r}
li_temp <- list(1, 2, 3)
rm(li_temp) # Removes object li_temp from the environment.
# li_temp no longer exists.
```

```{r}
iris
```

```{r}
with(iris, Sepal.Length * Sepal.Width) # with(): multiple columns can be accessed easily and can become part of an expression

```

```{r}
iris$new_column <- round(iris$Sepal.Length) # Adds new column to DataFrame iris.
iris
```

```{r}
with(iris, ifelse(Sepal.Length > 5, "A", "B")) # If TRUE, set A, else B.
```

```{r}
# If TRUE (Sepal.Length > 5), set A, else: If TRUE (Petal.Length > 1.3), set B, else C.
with(iris, ifelse(Sepal.Length > 5, "A", ifelse(Petal.Length > 1.3, "B", "C"))) 
```

```{r}
unique(iris$Species) # Gets unique values of column Species.
```

```{r}
subset(iris, Species == "setosa") # Gets only columns where Species is "setosa".
```

```{r}
# &: logic and; |: logic or.
subset(iris, (Species != "setosa" & Sepal.Length >= 5) | Petal.Length > 1.6)
```

```{r}
if (!require(dplyr)) {
  install.packages("dplyr")
  library(dplyr)
}
```

```{r}
filter(iris, Sepal.Length > 6) # filter() is part of dplyr.
```

```{r}
 mutate(iris, new_new_column = Sepal.Length * Sepal.Width) # Adds new column.
```

```{r}
arrange(iris, desc(Sepal.Length)) # Sorts by Sepal.Length.
```

```{r}
df1 <- data.frame(col_name1=c("A", "A", "B", "B", "C"), col_name2=c(1, 2, 3, 4, 5))
df2 <- data.frame(col_name1=c("A", "B", "C"), col_name2=c(10, 20, 30))

left_join(df1, df2, by="col_name1") # Joins two dfs by values of column with name col_name1.
```

```{r}
# Do what is on left of %>%, then do what is on right of %>%.
filter(iris, Sepal.Length > 4.0) %>% dplyr::select(Sepal.Length, Sepal.Width)
```

```{r}
filter(iris, Sepal.Length > 6.0) %>% dplyr::select(Sepal.Width, Petal.Length) %>% lapply(. %>% mean)
```

```{r}
iris %>% group_by(Species) %>% summarise_each(funs(mean)) # Must pass to funs() 
# function that needs to be executed.
```

```{r}
# iris[-5]: entire DataFrame, but without column 5 (Species); can't calculate values below for String.
summarise_each(iris[-5], funs(mean))
summarise_each(iris[-5], funs(median))
summarise_each(iris[-5], funs(sd)) # Standard deviation.
```

```{r}
summarise_each(iris[-5], funs(mean(., na.rm=TRUE))) # (., na.rm=True): will remove NA values.
summarise_each(iris[-5], funs(median(., na.rm=TRUE)))
```

```{r}
iris[-5] %>% mutate_each(funs(half= . / 2))
```

```{r}
with(iris, table(Species, Petal.Width)) # Gets counts; Species values will be rows
# and Petal.Width values will be columns.
```

```{r}
# prop: Gets fractions (relative counts / relative frequency) instead of counts.
# margin=1: frequency per row; margin=2: frequency per column.
with(iris, table(Species, Petal.Width)) %>% prop.table(margin=1) %>% round(., 2)
```

```{r}
save_to_csv <- with(iris, table(Species, Petal.Width)) %>% prop.table(margin=1) %>% round(., 2)
write.csv(save_to_csv, "data/species_petal_width.csv") # Saves table to CSV.
```

```{r}
# Gets correlation.
with(iris, cor(Sepal.Length, Petal.Length, use="pairwise.complete.obs"))
```

```{r}
correlation_matrix <- cor(iris[-5]) # [-5] excludes Species column, but what if 
# column index of Species changes?
correlation_matrix
```

```{r}
# Better solution, not dependent on column index of Species.
correlation_matrix <- dplyr::select(iris, -Species) %>% cor(.) 
correlation_matrix

```

```{r}
if(!require("ppcor")){
  install.packages("ppcor")
  library(ppcor)
}
```

```{r}
# Gives (partial) correlation of two variables (Sepal.Length and Sepal.Width) while
# controlling for a third variable (Petal.Length).
# https://www.rdocumentation.org/packages/ppcor/versions/1.1/topics/pcor.test

# dplyr::select() because library dplyr and library ppcor have a select() function.
# filter(complete.cases(.)): Takes only rows with non-missing values / existing values.
dplyr::select(iris, -Species) %>% filter(complete.cases(.)) %>% with(., pcor.test(Sepal.Length, Sepal.Width, Petal.Length))
```

```{r}
# Needed for below.
set.seed(5)
iris$group <- sample(1:3, 150, replace=TRUE) # Adds a group column to iris.
with(iris, table(group)) # Shows number of rows per group 1, 2, and 3.
```

```{r}
sepal_length_anova <- aov(Sepal.Length ~ as.factor(group), iris)
summary(sepal_length_anova)
# p-value > 0.05, do not reject null hypothesis: thus means for Sepal.Length of 
# 3 groups are not different.
#  Pr(>F) is p-value of associated F statistic.
```

```{r}
# If there was a difference between the groups (if above null hypothesis rejected), 
# it would be shown here between which groups. 
# If the p adj is less than 0.05 then there is a difference between the groups.
TukeyHSD(sepal_length_anova, conf.level=0.95)
```

```{r}
# Calculates means and confidence intervals for Sepal.Length for each group 1, 2, and 3.
group_means <- dplyr::select(iris, Sepal.Length, group) %>% filter(complete.cases(.)) %>% group_by(group) %>% summarise(mean=mean(Sepal.Length), sd=sd(Sepal.Length), Length=NROW(Sepal.Length), q2frac=qnorm(0.975), Lower=(mean - q2frac * sd / sqrt(Length)), Upper=(mean + q2frac * sd / sqrt(Length)))

# Plots means and confidence intervals for Sepal.Length for each group 1, 2, and 3.
ggplot(group_means, aes(x=mean, y=as.factor(group))) + geom_point() + geom_errorbarh(aes(xmin=Lower, xmax=Upper), height=0.3)
```

```{r}
# Encodes categorical Species column to use it in linear regression as target.
iris$Species_encoded <- as.numeric(iris$Species)
iris$Species_encoded 

# Linear regression.
# lm([target variable] ~ [predictor variables], data=[data source]).
lm_ <- lm(iris$Species_encoded ~ Sepal.Length + Sepal.Width + Petal.Length, data=iris)
summary(lm_)

```

```{r}
lm_$coefficients
```

```{r}
if(!require("mltools")){
  install.packages("mltools")
  library(mltools)
}

library(data.table)
```

```{r}
# Better is to one-hot encode target Species for linear regression.
iris_one_hot_encoded <- one_hot(as.data.table(iris))
iris_one_hot_encoded
```

```{r}
# Linear regression with one-hot encoded target.
lm_ <- lm(iris_one_hot_encoded$Species_setosa + iris_one_hot_encoded$Species_versicolor + iris_one_hot_encoded$Species_virginica  ~ Sepal.Length + Sepal.Width + Petal.Length, data=iris_one_hot_encoded)
summary(lm_)
```

```{r}
new_data <- data.frame(Sepal.Length=c(3, 4, 5), Sepal.Width=c(1, 2, 3), Petal.Length=c(1, 2, 3))
predicted <- predict(lm_, new_data) # Predict with model.
predicted
```

```{r}
# Assume that target variable is not categorical, but continuous variable.
# Can compare difference between actual and predicted target values.
compare <- data.frame(actual=c(1, 1, 1), predicted=c(1, 2, 3))
compare$diff <- with(compare, predicted - actual)
MAE <- with(compare, mean(abs(diff)))
print(MAE)

RMSE <-  with(compare, sqrt(sum(diff^2) / length(diff)))
RMSE
```

```{r}
hist(iris$Sepal.Length)
```

```{r}
# Only values no plot.
hist(iris$Sepal.Length, plot=FALSE)
```

```{r}
# Define bin sizes yourself.
hist(iris$Sepal.Length, breaks=c(0.0, 2.0, 4.0, 6.0, 8.0, 10.0))
```

```{r}
# Density / relative frequency instead of absolute frequency.
hist(iris$Sepal.Length, freq=FALSE)
```

```{r}
boxplot(iris$Sepal.Length, ylab="Sepal.Length")
```

```{r}
empty_plot <- ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width))
empty_plot
```

```{r}
# Colors points and creates separate plots.
empty_plot + geom_point(aes(color=Species)) + facet_wrap(~Species)
```

```{r}
# Adds trend line.
empty_plot + geom_point() + stat_smooth()
```

```{r}
rm(list=ls()) # Cleans entire environment.
```


